package com.newton.couplespace.screens.health.data.repository

import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.PermissionController
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.*
import androidx.health.connect.client.request.ReadRecordsRequest
import androidx.health.connect.client.time.TimeRangeFilter
import androidx.health.connect.client.records.metadata.Metadata
import androidx.health.connect.client.records.metadata.DataOrigin
import androidx.health.connect.client.aggregate.*
import androidx.health.connect.client.aggregate.AggregationType.*
import com.google.firebase.auth.FirebaseAuth
import com.newton.couplespace.screens.health.data.models.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import java.time.Instant
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.ZoneId
import java.time.ZoneOffset
import java.util.*
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Implementation of HealthConnectRepository that interacts with Health Connect API
 */
@Singleton
class HealthConnectRepositoryImpl @Inject constructor(
    private val context: Context,
    private val auth: FirebaseAuth
) : HealthConnectRepository {
    
    // Health Connect client
    override val healthConnectClient: HealthConnectClient? by lazy {
        if (isHealthConnectAvailable()) {
            HealthConnectClient.getOrCreate(context)
        } else {
            null
        }
    }
    
    // Required permissions for the app
    private val permissions = setOf(
        HealthPermission.getReadPermission(StepsRecord::class),
        HealthPermission.getReadPermission(HeartRateRecord::class),
        HealthPermission.getReadPermission(SleepSessionRecord::class),
        HealthPermission.getReadPermission(WeightRecord::class),
        HealthPermission.getReadPermission(TotalCaloriesBurnedRecord::class),
        HealthPermission.getReadPermission(DistanceRecord::class),
        HealthPermission.getReadPermission(ActiveCaloriesBurnedRecord::class),
        HealthPermission.getReadPermission(ExerciseSessionRecord::class),
        HealthPermission.getReadPermission(NutritionRecord::class),
        HealthPermission.getReadPermission(HeightRecord::class),
        HealthPermission.getReadPermission(HydrationRecord::class),
        HealthPermission.getReadPermission(OxygenSaturationRecord::class),
        HealthPermission.getReadPermission(RestingHeartRateRecord::class),
        HealthPermission.getReadPermission(Vo2MaxRecord::class)
    )
    
    override fun getRequiredPermissions(): Set<String> = permissions
    
    /**
     * Check if Health Connect is available on the device
     */
    override suspend fun isHealthConnectAvailable(): Boolean {
        return try {
            val availabilityStatus = HealthConnectClient.getSdkStatus(context)
            when (availabilityStatus) {
                HealthConnectClient.SDK_AVAILABLE -> true
                HealthConnectClient.SDK_UNAVAILABLE_PROVIDER_UPDATE_REQUIRED,
                HealthConnectClient.SDK_UNAVAILABLE -> false
                else -> false
            }
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Check if the app has all necessary Health Connect permissions
     */
    override suspend fun hasAllPermissions(): Boolean {
        if (!isHealthConnectAvailable()) return false
        
        return try {
            val granted = healthConnectClient?.permissionController?.getGrantedPermissions()
            granted?.containsAll(permissions) ?: false
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Request Health Connect permissions
     */
    override suspend fun requestPermissions(): PermissionController {
        return healthConnectClient?.permissionController ?: 
            throw IllegalStateException("Health Connect is not available")
    }
    
    /**
     * Get date range for health data
     */
    override suspend fun getDateRange(): Pair<LocalDate, LocalDate> {
        val client = healthConnectClient ?: return getDefaultDateRange()
        
        return try {
            // Get the earliest and latest data points for steps
            val stepsRequest = ReadRecordsRequest(
                recordType = StepsRecord::class,
                timeRangeFilter = TimeRangeFilter.after(Instant.EPOCH)
            )
            
            val steps = client.readRecords(stepsRequest)
            
            val startDate = steps.records.minByOrNull { it.startTime }?.startTime
                ?.atZone(ZoneId.systemDefault())?.toLocalDate()
                ?: LocalDate.now().minusMonths(1)
                
            val endDate = steps.records.maxByOrNull { it.endTime }?.endTime
                ?.atZone(ZoneId.systemDefault())?.toLocalDate()
                ?: LocalDate.now()
                
            startDate to endDate
        } catch (e: Exception) {
            // Fallback to default range if there's an error
            getDefaultDateRange()
        }
    }
    
    private fun getDefaultDateRange(): Pair<LocalDate, LocalDate> {
        val today = LocalDate.now()
        val thirtyDaysAgo = today.minusDays(30)
        return thirtyDaysAgo to today
    }
    
    /**
     * Get steps for a specific date
     */
    override suspend fun getStepsForDate(date: LocalDate): Flow<StepsMetric> = flow {
        val client = healthConnectClient ?: throw IllegalStateException("Health Connect is not available")
        
        try {
            val startOfDay = date.atStartOfDay(ZoneId.systemDefault()).toInstant()
            val endOfDay = date.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant()
            
            val request = ReadRecordsRequest(
                recordType = StepsRecord::class,
                timeRangeFilter = TimeRangeFilter.between(startOfDay, endOfDay)
            )
            
            val response = client.readRecords(request)
            val totalSteps = response.records.sumOf { it.count }
            
            emit(StepsMetric(
                id = "steps-${date}",
                userId = auth.currentUser?.uid ?: "unknown",
                timestamp = startOfDay.plusSeconds(43200), // Noon
                count = totalSteps,
                source = "Health Connect",
                isShared = false
            ))
        } catch (e: Exception) {
            // Fall back to mock data if there's an error
            emit(createMockStepsMetric(date))
        }
    }
    
    /**
     * Get heart rate for a specific date
     */
    override suspend fun getHeartRateForDate(date: LocalDate): Flow<HeartRateMetric> = flow {
        val heartRates = getHeartRateData(date, date)
        heartRates.collect { heartRateList ->
            heartRateList.firstOrNull()?.let { emit(it) } ?: emit(createMockHeartRateMetric(date))
        }
    }
    
    private fun createMockHeartRateMetric(date: LocalDate): HeartRateMetric {
        return HeartRateMetric(
            id = "mock-heart-rate-${date}",
            userId = "mock-user-id",
            timestamp = date.atTime(12, 0).toInstant(ZoneOffset.UTC),
            beatsPerMinute = (60..100).random(),
            source = "Mock Data",
            isShared = false
        )
    }
    
    private fun createMockStepsMetric(date: LocalDate): StepsMetric {
        return StepsMetric(
            id = "mock-steps-${date}",
            userId = "mock-user-id",
            timestamp = date.atTime(12, 0).toInstant(ZoneOffset.UTC),
            count = (3000..10000).random(),
            source = "Mock Data",
            isShared = false
        )
    }
    
    /**
     * Get step count for a date range
     */
    override suspend fun getStepCount(startDate: LocalDate, endDate: LocalDate): Flow<List<StepsMetric>> = flow {
        val client = healthConnectClient ?: throw IllegalStateException("Health Connect is not available")
        val stepsList = mutableListOf<StepsMetric>()
        
        try {
            val startTime = startDate.atStartOfDay(ZoneId.systemDefault()).toInstant()
            val endTime = endDate.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant()
            
            // Get aggregated steps for each day in the range
            var currentDate = startDate
            while (!currentDate.isAfter(endDate)) {
                val dayStart = currentDate.atStartOfDay(ZoneId.systemDefault()).toInstant()
                val dayEnd = currentDate.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant()
                
                val request = ReadRecordsRequest(
                    recordType = StepsRecord::class,
                    timeRangeFilter = TimeRangeFilter.between(dayStart, dayEnd)
                )
                
                val response = client.readRecords(request)
                val totalSteps = response.records.sumOf { it.count }
                
                stepsList.add(
                    StepsMetric(
                        id = "steps-${currentDate}",
                        userId = auth.currentUser?.uid ?: "unknown",
                        timestamp = dayStart.plusSeconds(43200), // Noon
                        count = totalSteps,
                        source = "Health Connect",
                        isShared = false
                    )
                )
                
                currentDate = currentDate.plusDays(1)
            }
        } catch (e: Exception) {
            // Fall back to mock data if there's an error
            stepsList.addAll(generateMockStepsData(startDate, endDate))
        }
        
        emit(stepsList)
    }
    
    private fun generateMockStepsData(startDate: LocalDate, endDate: LocalDate): List<StepsMetric> {
        val stepsList = mutableListOf<StepsMetric>()
        var currentDate = startDate
        
        while (!currentDate.isAfter(endDate)) {
            val timestamp = currentDate.atStartOfDay(ZoneId.systemDefault()).toInstant()
            stepsList.add(
                StepsMetric(
                    id = UUID.randomUUID().toString(),
                    userId = auth.currentUser?.uid ?: "mock-user-id",
                    timestamp = timestamp.plusSeconds(43200), // Noon
                    count = 5000 + (Math.random() * 5000).toInt(),
                    source = "Mock Data",
                    isShared = false
                )
            )
            currentDate = currentDate.plusDays(1)
        }
        
        return stepsList
    }
    
    /**
     * Get distance data for a date range
     */
    override suspend fun getDistanceData(startDate: LocalDate, endDate: LocalDate): Flow<List<DistanceMetric>> = flow {
        val userId = auth.currentUser?.uid ?: "mock-user-id"
        val distanceList = mutableListOf<DistanceMetric>()
        var currentDate = startDate
        
        // Generate mock distance data for each day in the range
        while (!currentDate.isAfter(endDate)) {
            val timestamp = currentDate.atStartOfDay(ZoneId.systemDefault()).toInstant()
            distanceList.add(
                DistanceMetric(
                    id = UUID.randomUUID().toString(),
                    userId = userId,
                    timestamp = timestamp.plusSeconds(43200), // Noon
                    distanceMeters = 3000 + (Math.random() * 5000),
                    source = "Mock Data",
                    isShared = false
                )
            )
            currentDate = currentDate.plusDays(1)
        }
        
        emit(distanceList)
    }
    
    /**
     * Get heart rate data for a date range
     */
    override suspend fun getHeartRateData(startDate: LocalDate, endDate: LocalDate): Flow<List<HeartRateMetric>> = flow {
        val client = healthConnectClient ?: throw IllegalStateException("Health Connect is not available")
        val heartRateList = mutableListOf<HeartRateMetric>()
        
        try {
            val startTime = startDate.atStartOfDay(ZoneId.systemDefault()).toInstant()
            val endTime = endDate.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant()
            
            val request = ReadRecordsRequest(
                recordType = HeartRateRecord::class,
                timeRangeFilter = TimeRangeFilter.between(startTime, endTime)
            )
            
            val response = client.readRecords(request)
            
            // Group readings by day and calculate average for each day
            val readingsByDay = response.records
                .groupBy { record ->
                    record.time.atZone(ZoneId.systemDefault()).toLocalDate()
                }
                .mapValues { (_, records) ->
                    records.flatMap { it.measurements }
                        .map { it.beatsPerMinute }
                        .average()
                        .toInt()
                }
            
            // Create metrics for each day with data
            readingsByDay.forEach { (date, avgBpm) ->
                heartRateList.add(
                    HeartRateMetric(
                        id = "hr-${date}",
                        userId = auth.currentUser?.uid ?: "unknown",
                        timestamp = date.atTime(12, 0).toInstant(ZoneOffset.UTC),
                        beatsPerMinute = avgBpm,
                        source = "Health Connect",
                        isShared = false
                    )
                )
            }
            
            // If no data, use mock data
            if (heartRateList.isEmpty()) {
                heartRateList.addAll(generateMockHeartRateData(startDate, endDate))
            }
        } catch (e: Exception) {
            // Fall back to mock data if there's an error
            heartRateList.addAll(generateMockHeartRateData(startDate, endDate))
        }
        
        emit(heartRateList)
    }
    
    private fun generateMockHeartRateData(startDate: LocalDate, endDate: LocalDate): List<HeartRateMetric> {
        val heartRateList = mutableListOf<HeartRateMetric>()
        var currentDate = startDate
        
        while (!currentDate.isAfter(endDate)) {
            val timestamp = currentDate.atStartOfDay(ZoneId.systemDefault()).toInstant()
            
            // Morning heart rate
            heartRateList.add(
                HeartRateMetric(
                    id = UUID.randomUUID().toString(),
                    userId = auth.currentUser?.uid ?: "mock-user-id",
                    timestamp = timestamp.plusSeconds(28800), // 8 AM
                    beatsPerMinute = 60 + (Math.random() * 40).toInt(),
                    source = "Mock Data",
                    isShared = false
                )
            )
            
            // Afternoon heart rate
            heartRateList.add(
                HeartRateMetric(
                    id = UUID.randomUUID().toString(),
                    userId = auth.currentUser?.uid ?: "mock-user-id",
                    timestamp = timestamp.plusSeconds(50400), // 2 PM
                    beatsPerMinute = 70 + (Math.random() * 20).toInt(),
                    source = "Mock Data",
                    isShared = false
                )
            )
            
            // Evening heart rate
            heartRateList.add(
                HeartRateMetric(
                    id = UUID.randomUUID().toString(),
                    userId = auth.currentUser?.uid ?: "mock-user-id",
                    timestamp = timestamp.plusSeconds(72000), // 8 PM
                    beatsPerMinute = 65 + (Math.random() * 10).toInt(),
                    source = "Mock Data",
                    isShared = false
                )
            )
            
            currentDate = currentDate.plusDays(1)
        }
        
        return heartRateList
    }
    
    /**
     * Get sleep data for a date range
     */
    override suspend fun getSleepData(startDate: LocalDate, endDate: LocalDate): Flow<List<SleepMetric>> = flow {
        val userId = auth.currentUser?.uid ?: "mock-user-id"
        val sleepList = mutableListOf<SleepMetric>()
        var currentDate = startDate
        
        // Generate mock sleep data for each day in the range
        while (!currentDate.isAfter(endDate)) {
            val bedtime = currentDate.atTime(22, 0).atZone(ZoneId.systemDefault()).toInstant() // 10 PM
            val wakeTime = currentDate.plusDays(1).atTime(6, 0).atZone(ZoneId.systemDefault()).toInstant() // 6 AM
            val durationHours = 6 + (Math.random() * 3).toFloat()
            
            sleepList.add(
                SleepMetric(
                    id = UUID.randomUUID().toString(),
                    userId = userId,
                    timestamp = bedtime,
                    startTime = bedtime,
                    endTime = wakeTime,
                    durationHours = durationHours,
                    quality = SleepMetric.SleepQuality.GOOD,
                    source = "Mock Data",
                    isShared = false
                )
            )
            
            currentDate = currentDate.plusDays(1)
        }
        
        emit(sleepList)
    }
    
    /**
     * Get weight data for a date range
     */
    override suspend fun getWeightData(startDate: LocalDate, endDate: LocalDate): Flow<List<WeightMetric>> = flow {
        val userId = auth.currentUser?.uid ?: "mock-user-id"
        val weightList = mutableListOf<WeightMetric>()
        var currentDate = startDate
        
        // Generate mock weight data for each day in the range
        while (!currentDate.isAfter(endDate)) {
            val timestamp = currentDate.atStartOfDay(ZoneId.systemDefault()).toInstant()
            
            weightList.add(
                WeightMetric(
                    id = UUID.randomUUID().toString(),
                    userId = userId,
                    timestamp = timestamp.plusSeconds(28800), // 8 AM
                    weightKg = 70.0 + (Math.random() - 0.5),
                    source = "Mock Data",
                    isShared = false
                )
            )
            
            currentDate = currentDate.plusDays(1)
        }
        
        emit(weightList)
    }
    
    /**
     * Get calories burned for a date range
     */
    override suspend fun getCaloriesBurnedData(startDate: LocalDate, endDate: LocalDate): Flow<List<CaloriesBurnedMetric>> = flow {
        val userId = auth.currentUser?.uid ?: "mock-user-id"
        val caloriesList = mutableListOf<CaloriesBurnedMetric>()
        var currentDate = startDate
        
        // Generate mock calories burned data for each day in the range
        while (!currentDate.isAfter(endDate)) {
            val timestamp = currentDate.atStartOfDay(ZoneId.systemDefault()).toInstant()
            
            // Morning workout
            caloriesList.add(
                CaloriesBurnedMetric(
                    id = UUID.randomUUID().toString(),
                    userId = userId,
                    timestamp = timestamp.plusSeconds(28800), // 8 AM
                    calories = 100 + (Math.random() * 200).toInt(),
                    source = "Mock Data",
                    activity = "Morning Run",
                    isShared = false
                )
            )
            
            // Afternoon activity
            caloriesList.add(
                CaloriesBurnedMetric(
                    id = UUID.randomUUID().toString(),
                    userId = userId,
                    timestamp = timestamp.plusSeconds(50400), // 2 PM
                    calories = 100 + (Math.random() * 50).toInt(),
                    source = "Mock Data",
                    activity = "Walking",
                    isShared = false
                )
            )
            
            // Evening workout
            caloriesList.add(
                CaloriesBurnedMetric(
                    id = UUID.randomUUID().toString(),
                    userId = userId,
                    timestamp = timestamp.plusSeconds(68400), // 7 PM
                    calories = 250 + (Math.random() * 100).toInt(),
                    source = "Mock Data",
                    activity = "Gym Workout",
                    isShared = false
                )
            )
            
            currentDate = currentDate.plusDays(1)
        }
        
        emit(caloriesList)
    }
    
    /**
     * Get calories burned for a specific date
     */
    override suspend fun getCaloriesBurnedForDate(date: LocalDate): Flow<CaloriesBurnedMetric> = flow {
        val caloriesBurned = getCaloriesBurnedData(date, date)
        caloriesBurned.collect { caloriesList ->
            caloriesList.firstOrNull()?.let { emit(it) } ?: emit(createMockCaloriesBurnedMetric(date))
        }
    }
    
    private fun createMockCaloriesBurnedMetric(date: LocalDate): CaloriesBurnedMetric {
        return CaloriesBurnedMetric(
            id = "mock-calories-${date}",
            userId = "mock-user-id",
            timestamp = date.atTime(12, 0).toInstant(ZoneOffset.UTC),
            calories = (1800..2500).random(),
            source = "Mock Data",
            activity = listOf("Walking", "Running", "Cycling", "Swimming").random(),
            isShared = false
        )
    }
    
    /**
     * Get sleep duration for a specific date
     */
    override suspend fun getSleepDataForDate(date: LocalDate): Flow<SleepMetric> = flow {
        val sleepData = getSleepData(date, date)
        sleepData.collect { sleepList ->
            sleepList.firstOrNull()?.let { emit(it) } ?: emit(createMockSleepMetric(date))
        }
    }
    
    private fun createMockSleepMetric(date: LocalDate): SleepMetric {
        val sleepStart = date.minusDays(1).atTime(23, 0).toInstant(ZoneOffset.UTC)
        val sleepEnd = date.atTime(7, 30).toInstant(ZoneOffset.UTC)
        return SleepMetric(
            id = "mock-sleep-${date}",
            userId = "mock-user-id",
            timestamp = sleepStart,
            startTime = sleepStart,
            endTime = sleepEnd,
            durationHours = (6.5f..9.0f).random(),
            quality = SleepMetric.SleepQuality.values().random(),
            source = "Mock Data",
            isShared = false
        )
    }
    
    /**
     * Get heart rate for a specific date
     */
    override suspend fun getHeartRateForDate(date: LocalDate): Flow<HeartRateMetric> = flow {
        val heartRates = getHeartRateData(date, date)
        heartRates.collect { heartRateList ->
            heartRateList.firstOrNull()?.let { emit(it) } ?: emit(createMockHeartRateMetric(date))
        }
    }
    
    private fun createMockHeartRateMetric(date: LocalDate): HeartRateMetric {
        return HeartRateMetric(
            id = "mock-heart-rate-${date}",
            userId = "mock-user-id",
            timestamp = date.atTime(12, 0).toInstant(ZoneOffset.UTC),
            beatsPerMinute = (60..100).random(),
            source = "Mock Data",
            isShared = false
        )
    }
    
    /**
     * Get active minutes for a specific date
     */
    override suspend fun getActiveMinutesForDate(date: LocalDate): Flow<ActiveMinutesMetric> = flow {
        val userId = auth.currentUser?.uid ?: "mock-user-id"
        val client = healthConnectClient
        
        if (client == null || !hasAllPermissions()) {
            // Fall back to mock data if Health Connect is not available or permissions are not granted
            emit(createMockActiveMinutesMetric(date))
            return@flow
        }
        
        try {
            // Create time range for the specific date
            val startTime = date.atStartOfDay(ZoneId.systemDefault()).toInstant()
            val endTime = date.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant()
            val timeRangeFilter = TimeRangeFilter.between(startTime, endTime)
            
            // Try to get active minutes from exercise sessions first
            val exerciseRequest = ReadRecordsRequest(
                recordType = ExerciseSessionRecord::class,
                timeRangeFilter = timeRangeFilter
            )
            
            val exerciseResponse = client.readRecords(exerciseRequest)
            val exerciseRecords = exerciseResponse.records
            
            if (exerciseRecords.isNotEmpty()) {
                // Calculate total active minutes from exercise sessions
                var totalActiveMinutes = 0L
                exerciseRecords.forEach { record ->
                    val duration = record.endTime.epochSecond - record.startTime.epochSecond
                    totalActiveMinutes += duration / 60 // Convert seconds to minutes
                }
                
                emit(
                    ActiveMinutesMetric(
                        id = UUID.randomUUID().toString(),
                        userId = userId,
                        timestamp = startTime.plusSeconds(43200), // Noon
                        minutes = totalActiveMinutes.toInt(),
                        intensity = ActiveMinutesMetric.ActivityIntensity.MODERATE,
                        source = "Health Connect",
                        isShared = false
                    )
                )
            } else {
                // Fall back to steps-based estimation if no exercise data
                val stepsRequest = ReadRecordsRequest(
                    recordType = StepsRecord::class,
                    timeRangeFilter = timeRangeFilter
                )
                
                val stepsResponse = client.readRecords(stepsRequest)
                val stepsRecords = stepsResponse.records
                
                if (stepsRecords.isNotEmpty()) {
                    // Estimate active minutes based on steps (rough estimate: 100 steps = 1 active minute)
                    var totalSteps = 0L
                    stepsRecords.forEach { record ->
                        totalSteps = totalSteps.plus(record.count)
                    }
                    
                    val estimatedActiveMinutes = (totalSteps / 100L).coerceAtMost(60L).toInt()
                    
                    emit(
                        ActiveMinutesMetric(
                            id = UUID.randomUUID().toString(),
                            userId = userId,
                            timestamp = startTime.plusSeconds(43200), // Noon
                            minutes = estimatedActiveMinutes,
                            intensity = ActiveMinutesMetric.ActivityIntensity.LIGHT,
                            source = "Health Connect (Estimated from Steps)",
                            isShared = false
                        )
                    )
                } else {
                    // No data available, emit zero active minutes
                    emit(
                        ActiveMinutesMetric(
                            id = UUID.randomUUID().toString(),
                            userId = userId,
                            timestamp = startTime.plusSeconds(43200), // Noon
                            minutes = 0,
                            intensity = ActiveMinutesMetric.ActivityIntensity.LIGHT,
                            source = "Health Connect",
                            isShared = false
                        )
                    )
                }
            }
        } catch (e: Exception) {
            // Fall back to mock data on error
            emit(createMockActiveMinutesMetric(date, "Mock Data (Error: ${e.message})"))
        }
    }
    
    private fun createMockActiveMinutesMetric(
        date: LocalDate,
        source: String = "Mock Data"
    ): ActiveMinutesMetric {
        val timestamp = date.atStartOfDay(ZoneId.systemDefault()).toInstant()
        return ActiveMinutesMetric(
            id = "mock-active-minutes-${date}",
            userId = "mock-user-id",
            timestamp = timestamp.plusSeconds(43200), // Noon
            minutes = (15..120).random(),
            intensity = listOf(
                ActiveMinutesMetric.ActivityIntensity.LIGHT,
                ActiveMinutesMetric.ActivityIntensity.MODERATE,
                ActiveMinutesMetric.ActivityIntensity.VIGOROUS
            ).random(),
            source = source,
            isShared = false
        )
    }
}